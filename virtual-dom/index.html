<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Virtual DOM is not a feature</title>
    <link rel="stylesheet" href="codemirror.css" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div class="page">

      <h1>Virtual DOM is not a feature</h1>
      <p>This is a blog post came from building a tiny dependency-free prototyping-oriented react-inspired javascript framework (because that's exactly what the world needs more of, right?). I don't really blog, but here we are.</p>
      <p>React's Virtual DOM is sold as an optimization bolted onto a declarative UI to make it fast. I tried to build the slow version, and learned that Virtual DOM is not an optimization, but rather a foundational building block for declarative UIs on the web.</p>

      <h2>A Declarative UI</h2>
      <p><a href="https://facebook.github.io/react/">React</a> is popular tool for building web application User Interfaces ("UIs" or "Views"). With React, developers write code that declaratively specifies what the UI should look like at any given point, without worrying about how to change the interface between states.</p>
      <p>Here's a React component:</p>
      <textarea id="compare-react">
const Button = React.createClass({
  getInitialState() {
    return { count: 0 };
  },
  handleClick() {
    this.setState({ count: this.state.count + 1 });
  },
  render() {
    return React.createElement('button',
      { onClick: this.handleClick },
      'I have been clicked ' + this.state.count + ' times.');
  },
});

ReactDOM.render(React.createElement(Button),
  document.getElementById('react-demo-app'));</textarea>
      <div class="demo">
        <code>#react-demo-app</code>
        <div id="react-demo-app">
        </div>
      </div>

      <p>What's notable about React code is what it doesn't do. The above code says nothing about how to:</p>
      <ul>
        <li>append DOM nodes,</li>
        <li>attach event listeners,</li>
        <li>change a DOM node's text content</li>
      </ul>
      <p>...so this is cool.</p>

      <h2>Achieving a declarative UI: Virtual DOM</h2>
      <p>The React example works because React re-renders components any time their `state` changes. In React, a component "rendering" produces a "Virtual DOM", which is a light-weight javascript representation of what we would like the actual DOM to look like.</p>
      <p>In order to update the real DOM, React first compares the new Virtual DOM to the Virtual DOM from the last render, and then applies the changes it finds to the real DOM to bring it up to date.</p>
      <p>It turns out that this can be really fast, because it avoids making unnecessary changes to the DOM. Changing the DOM is slow.</p>

      <h2>Attempting to achieve a declarative UI the slow way</h2>
      <p>The DOM may be slow, but computers are fast. What happens if we just blow away the entire DOM, and replace it with a new one created from scratch instead of messing around with Virtual DOMs? Can we get a declarative UI that works like React but slower?</p>
      <p>Here's my attempt:</p>

      <textarea id="replace-dom-clickcount">
// Helper: DOM Node factory
function d(tagName, events, children) {
  const el = document.createElement(tagName);
  Object.keys(events).forEach(evt =>
    el.addEventListener(evt, events[evt]));
  children.forEach(child => el.appendChild(child));
  return el;
}
// Helper: Text node factory
function t(content) {
  return document.createTextNode(content);
}

// Global state woo!
var clickCount = 0;

// Handle state change and re-render
function increment() {
  clickCount += 1;
  replaceDOM();
}

// Our declarative button component:
const Button = () =>
  d('button', { click: () => increment() }, [
    t('I\'ve been clicked ' + clickCount + ' times.'),
  ]);

// All the gory DOM stuff
const root = document.getElementById('replace-dom-app');
function replaceDOM() {
  // blow away the current DOM
  while (root.lastChild) root.removeChild(root.lastChild);
  // and replace it with a new DOM
  root.appendChild(Button());
}

// kick things off (we need a first render)
replaceDOM();</textarea>
      <div class="demo">
        <code>#replace-dom-app</code>
        <div id="replace-dom-app"></div>
      </div>

      <h3>So, React in 30 lines?</h3>
      <p>There's a big problem with this technique, already showing in the click-counting button example above. See it? I'll make it more obvious:</p>
      <textarea id="replace-dom-charcount">
// A declarative character-counting text input component
const CharCounter = () =>
  d('div', {}, {}, [
    d('input', {
      value: inputText
    }, {
      input: e => setText(e.target.value)
    }, []),
    t('You have entered ' + inputText.length + ' characters'),
  ]);

var inputText = '';

function setText(text) {
  inputText = text;
  replaceDOM();
}

function d(tagName, attrs, events, children) {
  const el = document.createElement(tagName);
  Object.keys(attrs).forEach(atr => el[atr] = attrs[atr]);
  // ^^ see postscript for tricky attribute edge-case
  Object.keys(events).forEach(evt =>
    el.addEventListener(evt, events[evt]));
  children.forEach(child => el.appendChild(child));
  return el;
}
function t(content) { return document.createTextNode(content); }


const root = document.getElementById('charcount-app');
function replaceDOM() {
  while (root.lastChild) root.removeChild(root.lastChild);
  root.appendChild(CharCounter());
}

// kick things off (we need a first render)
replaceDOM();</textarea>
      <div class="demo">
        <code>#charcount-app</code>
        <div id="charcount-app"></div>
      </div>

      <p>After you enter each character, the <code>&lt;input&gt;</code> you're typing in gets blown away. It's replaced with a new one that looks the same, but it's not the same input at all, and you're cursor is not focused on it. Same with the click-counting <code>&lt;button&gt;</code>: if you focus it and try to activate it multiple times with the space-bar, you'll find that it won't.</p>

      <h3>Refresh vs. Update Semantics</h3>
      <p>The broken demos above work correctly as specified, but they are horribly broken because the semantics are wrong. Blowing away the DOM and making a new one is like a page-reload, and, (unsurprisingly in hindsight), all transient UI state like `:hover`, `:focus`, and even scroll position, are blown away along with the DOM.</p>
      <blockquote>
        <p>When the data changes, React conceptually hits the "refresh" button, and knows to only update the changed parts.</p>
        <cite>&ndash; <a href="https://facebook.github.io/react/docs/why-react.html#declarative">Why React</a> from the React documentation</cite>
      </blockquote>
      <p><strong>Re-rendering in React is not like a page refresh</strong>, because all of that transient state is maintained. The DOM is not "effectively replaced", it's <strong>just mutated</strong>.</p>
      <p>Does this difference in semantics matter? Probably not. Even React's own documentation gets it wrong. But thanks for reading anyway :)</p>
      <h2>If not the Virtual DOM, what is the feature that makes React fast?</h2>
      <p>React needs a description of what you want the DOM to look like in order to choose the DOM mutations it will perform to make it so. That's the Virtual DOM. It's an implementation detail of creating a declarative UI library, not an optimization.</p>
      <p>Reacts killer speed feature is its nifty algorithms that <strong>operate on</strong> the Virtual DOM in order to quickly compute a sufficient but small number of DOM mutations to perform on the actual page to bring it up to date, not the Virtual DOM itself. That's it!</p>

      <hr />

      <p>Thanks for reading. Let me know what you think, I'm <a href="https://twitter.com/uncyclephil">@uncyclephil</a> on twitter.</p>
      <p>If I get around to it or if anyone is interested, I'll write another post about another tricky problem for declarative web UIs: resolving recursive state updates triggered by DOM updates.</p>

      <hr />

      <h3>Postscript: The ugly <code>Element.setAttribute</code> special case: <code>value</code></h3>
      <p>Most HTML attributes can be set on DOM elements via <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute"><code>Element.setAttribute(attrName, value)</code></a>, but unfortunately, <code>value</code> is special, and can't be set in this way. It has to be assigned to the element directly instead (<code>el.value = 'some text'</code> instead of <code>el.setAttribute('value', 'some text')</code>). The example code in the post ignores this special case for clarity. As far as I can find, <code>value</code> is the only special attribute that can't be assigned via <code>Element.setAttribute</code>. Friends, the web platform!</p>
      <p>Special-case handling for looping <code>attrs</code> might look like this:</p>
      <textarea id="ps">
attrs.forEach(attr =>
  attr === 'value'
    ? el = attrs[attr]
    : el.setAttribute(attr, attrs[attr]));</textarea>

      <h3>Post-Postscript: Can we get page-reload semantics if we exhaustively declare even transient state?</h3>
      <p>The problem with the blow-the-dom-away approach above was that we lost transient state like <code>:focus</code> (that we might not want to track ourselves) every time we replaced the DOM. What if did track and control all that extra state?</p>
      <p>Starting with <code>focus</code>:</p>
      <textarea id="controlled-focus">
// Callbacks to restore transient state after replacing the DOM
var toFocus = null;

// a new DOM factory that knows how to set focus state
function d(tagName, attrs, focus, events, children) {
  const el = document.createElement(tagName);
  Object.keys(attrs).forEach(atr => el[atr] = attrs[atr]);
  Object.keys(events).forEach(evt =>
    el.addEventListener(evt, events[evt]));
  children.forEach(child => el.appendChild(child));
  if (focus) toFocus = el;  // should probably validate that we
                            // aren't trying to focus > 1 el
  return el;
}
function t(content) { return document.createTextNode(content); }

var isReplacingDOM = false;  // a guard so we can ignore focus/blur
                             // events during our update

var isFocused = false;
var inputText = '';

// A helper to ensure a guarded re-render after state updates
const updater = fn => function(/* arguments */) {
  if (!isReplacingDOM) {
    fn.apply(null, arguments);
    replaceDOM();
  }
}

// state updaters
const focusInput = updater(() => isFocused = true);
const blurInput = updater(() => isFocused = false);
const changeText = updater(newValue => inputText = newValue);


const CharCounter = () =>
  d('div', {}, false, {}, [
    d('input', {
      value: inputText,
    },
    isFocused,
    {
      input: e => changeText(e.target.value),
      focus: () => focusInput(),
      blur: () => blurInput(),
    }, []),
    t('You have entered ' + inputText.length + ' characters'),
  ]);


const root = document.getElementById('controlled-focus-app');
function replaceDOM() {
  // guard against focus/blur events triggered by adding/
  // removing dom nodes triggering state updates
  isReplacingDOM = true;
  // blow away the current DOM
  while (root.lastChild) root.removeChild(root.lastChild);
  // and replace it with a new DOM
  root.appendChild(CharCounter());
  // restore focus state
  if (toFocus) toFocus.focus();
  // and reset
  toFocus = false;
  // re-enable state updates
  isReplacingDOM = false;
}

replaceDOM()</textarea>
      <div class="demo">
        <code>#controlled-focus-app</code>
        <div id="controlled-focus-app"></div>
      </div>
    </div>

    <script src="codemirror.js"></script>
    <script src="javascript.js"></script>
    <script src="react-0.14.3.js"></script>
    <script src="react-dom-0.14.3.js"></script>
    <script>
'use strict';
CodeMirror.defaults.viewportMargin = Infinity;
const evil = cm => eval(`(function() { 'use strict'; ${cm.getValue()} })()`);
function mirror(src) {
  const cm = CodeMirror.fromTextArea(document.querySelector(src));
  cm.on('change', evil);
  evil(cm);
}
mirror('#compare-react');
mirror('#replace-dom-clickcount');
mirror('#replace-dom-charcount');
CodeMirror.fromTextArea(document.querySelector('#ps'));
mirror('#controlled-focus');
    </script>
  </body>
</html>
